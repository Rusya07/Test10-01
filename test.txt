1) Promise - объект в JS, который связывает «создающий» и «потребляющий» коды вместе.
Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
resolve(value) — если работа завершилась успешно, с результатом value.
reject(error) — если произошла ошибка, error – объект ошибки.


2) async/await - это синтакс для работы с промисами

async - это функция возвращает промис
Пример: async function f() {
  return Promise.resolve(1);
}

f().then(alert);


await- можно использовать только внутри функции async
await заставит  JavaScript ждать до тех пор, пока промис справа от await не выполнится.
После чего оно вернёт его результат, и выполнение кода продолжится.
Пример: sync function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится

  alert(result);
}

f();


3) Поведение ключевого слова this в JavaScript несколько отличается по сравнению с остальными языками.
Имеются также различия при использовании this в строгом и нестрогом режиме.
Пример: const test = {
  prop: 42,
  func: function() {
    return this.prop;
  },
};

console.log(test.func());


4) Замыкание это комбинация функции и лексического окружения, в котором эта функция была определена.
Другими словами, замыкание даёт вам доступ к Scope внешней функции из внутренней функции.
В JavaScript замыкания создаются каждый раз при создании функции, во время её создания
Пример: function init() {
    var name = "GeekTech"; name - локальная переменная, созданная в init
    function displayName() { displayName() - внутренняя функция, замыкание
        alert (name); displayName() использует переменную, объявленную в родительской функции
    }
    displayName();

init();


5) Использование стрелочных функций может вас упрощать код,
принципом единственной ответственности (каждая функция отвечает только за одно конкретное действие).
Пример: const #name = (2, 4) => {
  const result = 2 + 4;
  return result;
};

Есть ещё функции первого класса. Это функции , которые используются как обычные переменные.
Они могут выступать аргументами для других функций или возвращать их в качестве результата.
Пример: document.querySelector('div').addEventListner('click', function() {
  alert('click happened');
});
Пример с возвращением: const #name = a => b => a + b;

myFirstClassArrow(1)(2); //=3